knitr::opts_chunk$set(echo = TRUE)
#Ejecute las siguientes tres líneas de código para crear las variables
x = c(1, 2, 4, 7, 9, 0)
y = 4
z = c(0.5, 2, 3, 5, 1, 0)
# Escriba en el siguiente espacio la operación suma entre "x" y "y", y asígnelo a resultado_suma (1 línea de código)
resultado_suma <-
# Escriba en el siguiente espacio la operación multiplicación entre "x" y "z", y asígnelo a resultado_multiplicacion (1 línea de código)
resultado_multiplicacion <-
# Escriba en el siguiente espacio la operación multiplicación negativa a "z", y asígnelo a resultado_negativo (1 línea de código)
resultado_negativo <-
# Escriba en el siguiente espacio la operación de raíz cuadrada "y", y asígnelo a resultado_raiz (1 línea de código)
resultado_raiz <-
# Escriba en el siguiente espacio la operación lógica de igualdad entre "x" y "z", y asígnelo a resultado_igualdad (1 línea de código)
resultado_igualdad <-
# Escriba en el siguiente espacio la operación lógica de diferencia entre "x" y "y", y asígnelo a resultado_igualdad (1 línea de código)
resultado_diferencia <-
# --------------------------- #
# Ahora ejecute las siguientes líneas de código que le permitirán observar los resultados de sus operaciones.
print("Resultado Suma")
resultado_suma
print("Resultado multiplicación")
resultado_multiplicacion
print("Resultado negativo")
resultado_negativo
print("Resultado raíz cuadrada")
resultado_raiz
print("Resultado de operación lógica: igualdad")
resultado_igualdad
print("Resultado de operación lógica: diferencia")
resultado_diferencia
x = c(1, 2, 4, 7, 9, 0)
y = 4
z = c(0.5, 2, 3, 5, 1, 0)
x = c(1, 2, 4, 7, 9, 0)
y = 4
z = c(0.5, 2, 3, 5, 1, 0)
#Ejecute las siguientes tres líneas de código para crear las variables
x = c(1, 2, 4, 7, 9, 0)
y = 4
z = c(0.5, 2, 3, 5, 1, 0)
# Escriba en el siguiente espacio la operación suma entre "x" y "y", y asígnelo a resultado_suma (1 línea de código)
resultado_suma <- x+y
# Escriba en el siguiente espacio la operación multiplicación entre "x" y "z", y asígnelo a resultado_multiplicacion (1 línea de código)
resultado_multiplicacion <- x*z
# Escriba en el siguiente espacio la operación multiplicación negativa a "z", y asígnelo a resultado_negativo (1 línea de código)
resultado_negativo <- -z
# Escriba en el siguiente espacio la operación de raíz cuadrada "y", y asígnelo a resultado_raiz (1 línea de código)
resultado_raiz <- sqrt(y)
# Escriba en el siguiente espacio la operación lógica de igualdad entre "x" y "z", y asígnelo a resultado_igualdad (1 línea de código)
resultado_igualdad <- x==z
# Escriba en el siguiente espacio la operación lógica de diferencia entre "x" y "y", y asígnelo a resultado_igualdad (1 línea de código)
resultado_diferencia <- x!=y
# --------------------------- #
# Ahora ejecute las siguientes líneas de código que le permitirán observar los resultados de sus operaciones.
print("Resultado Suma")
resultado_suma
print("Resultado multiplicación")
resultado_multiplicacion
print("Resultado negativo")
resultado_negativo
print("Resultado raíz cuadrada")
resultado_raiz
print("Resultado de operación lógica: igualdad")
resultado_igualdad
print("Resultado de operación lógica: diferencia")
resultado_diferencia
knitr::opts_chunk$set(echo = TRUE)
#install.packages("tidyverse")
install.packages("nycflights13")
#install.packages("tidyverse")
#install.packages("nycflights13")
#install.packages("xts")
install.packages("PerformanceAnalytics")
anova(reg2,reg1)
data<-read.csv(file.choose())
head(data,3)
D<-year>=1991
data$D<-as.numeric(D)
data[29:36,]
reg1<-lm(log_PIB_Col~D+log_PIB_USA+D*log_PIB_USA,data = data)
reg2<-lm(log_PIB_Col~log_PIB_USA,data=data)
anova(reg2,reg1)
data<-read.csv(file.choose())
attach(data)
D<-year>=1991
data$D<-as.numeric(D)
data[29:36,]
reg1<-lm(log_PIB_Col~D+log_PIB_USA+D*log_PIB_USA,data = data)
reg2<-lm(log_PIB_Col~log_PIB_USA,data=data)
anova(reg2,reg1)
data <- read_excel(file.choose())
library(readxl)
data <- read_excel(file.choose())
setwd("F:/GitHub/Maestría en Ciencia de Datos/Análisis Cuantitativo/Archivos")
data<-read.csv("DatosTallerSelAuto.csv",sep=",")
data<-data[,-c(1:2)]
bwdmodel <- lm(shares ~ num_hrefs + average_token_length + data_channel_is_entertainment + kw_min_min +
kw_min_avg + kw_max_avg + kw_avg_avg + self_reference_min_shares  +
avg_negative_polarity, data = data)
summary(bwdmodel)
#num_hrefs, average_token_length, data_channel_is_entertainment, kw_min_min + kw_min_avg,
#kw_max_avg, kw_avg_avg, self_reference_min_shares y max_negative_polarity.
install.packages(car)
library(car)
vif(bwdmodel)
#Esto nos dice que hay multicolinealidad en kw_max_avg, kw_avg_avg
XTX <- model.matrix(bwdmodel)
e <- eigen(t(XTX) %*% XTX)
e$val
lambda.1 <- max(e$val)
lambda.k <- min(e$val)
kappa <- sqrt(lambda.1/lambda.k)
kappa
remueve.VIF.grande <- function(modelo, u){
require(car)
# extrae el dataframe
data <- modelo$model
# Calcula todos los VIF
all_vifs <- car::vif(modelo)
# extraer el nombre de todas las variables X
names_all <- names(all_vifs)
# extraer el nombre de la variables y
dep_var <- all.vars(formula(modelo))[1]
# Remover lsa variables con VIF > u
# y reestimar el modelo con las otras variables
while(any(all_vifs > u)){
# elimina variable con max vif
var_max_vif <- names(which(all_vifs == max(all_vifs)))
# remueve la variable
names_all <- names_all[!(names_all) %in% var_max_vif]
# nueva formula
myForm <- as.formula(paste(paste(dep_var, "˜ "),
paste (names_all, collapse=" + "), sep=""))
# re-build model with new formula
modelo.prueba <- lm(myForm, data= data)
all_vifs <- car::vif(modelo.prueba)
}
modelo.limpio <- modelo.prueba
return(modelo.limpio)
}
modeloGenial<-remueve.VIF.grande(bwdmodel,4)
remueve.VIF.grande <- function(modelo, u){
require(car)
# extrae el dataframe
data <- modelo$model
# Calcula todos los VIF
all_vifs <- car::vif(modelo)
# extraer el nombre de todas las variables X
names_all <- names(all_vifs)
# extraer el nombre de la variables y
dep_var <- all.vars(formula(modelo))[1]
# Remover lsa variables con VIF > u
# y reestimar el modelo con las otras variables
while(any(all_vifs > u)){
# elimina variable con max vif
var_max_vif <- names(which(all_vifs == max(all_vifs)))
# remueve la variable
names_all <- names_all[!(names_all) %in% var_max_vif]
# nueva formula
myForm <- as.formula(paste(paste(dep_var, "~ "),
paste (names_all, collapse=" + "), sep=""))
# re-build model with new formula
modelo.prueba <- lm(myForm, data= data)
all_vifs <- car::vif(modelo.prueba)
}
modelo.limpio <- modelo.prueba
return(modelo.limpio)
}
modeloGenial<-remueve.VIF.grande(bwdmodel,4)
summary(modeloGenial)
bwdmodel <- lm(shares ~ num_hrefs + average_token_length + data_channel_is_entertainment + kw_min_min +
kw_min_avg + kw_max_avg + kw_avg_avg + self_reference_min_shares  +
max_negative_polarity, data = data)
vif(bwdmodel)
#Esto nos dice que hay multicolinealidad en kw_max_avg, kw_avg_avg
XTX <- model.matrix(bwdmodel)
e <- eigen(t(XTX) %*% XTX)
e$val
lambda.1 <- max(e$val)
lambda.k <- min(e$val)
kappa <- sqrt(lambda.1/lambda.k)
kappa
modeloGenial<-remueve.VIF.grande(bwdmodel,4)
summary(modeloGenial)
vif(bwdmodel)
kappa
summary(modeloGenial)
vif(bwdmodel)
kappa
summary(modeloGenial)
vif(modeloGenial)
